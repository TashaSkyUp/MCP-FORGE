"""
Helpers for writing and loading collected tool modules.

This module hides filesystem operations and module loading behind function
calls that defer imports to respect the style preference that imports live
inside functions.
"""

from __future__ import annotations
from typing import List, Tuple, Any

def ensure_dirs(base_dir: str) -> str:
    """Ensure ``base_dir`` exists, creating it if necessary, and return it."""
    def _impl() -> str:
        import os
        os.makedirs(base_dir, exist_ok=True)
        return base_dir
    return _impl()

def safe_mod_name(name: str) -> str:
    """Sanitize an arbitrary string into a valid Python module name."""
    def _impl() -> str:
        import re
        s = re.sub(r"[^a-zA-Z0-9_]+", "_", name.strip())
        if not s:
            s = "tool"
        if s[0].isdigit():
            s = "_" + s
        return s.lower()
    return _impl()

def write_tool_module(
    base_dir: str,
    module_name: str,
    code_blob: str,
    func_name: str,
    tool_name: str,
    description: str,
    arg_spec: List[Tuple[str, str]],
) -> str:
    """
    Persist a generated module that wraps a function from ``code_blob`` as an MCP tool.
    """
    def _impl() -> str:
        import os
        import json
        ensure_dirs(base_dir)
        args_decl = ", ".join([f"{n}: {t}" for (n, t) in arg_spec]) or ""
        kwargs_pass = ", ".join([f"{n}={n}" for (n, _t) in arg_spec]) or ""
        file_text = f'''# AUTO-GENERATED BY MCPForge. Do not edit by hand.
from typing import Any

def register(mcp):
    """Register tool '{tool_name}' from collected code snippet."""
    def _wrapper({args_decl}) -> Any:
        # All imports inside function, per style preference.
        import types
        ns = {{}}
        src = {json.dumps(code_blob)}
        # Execute snippet in isolated namespace
        exec(src, {{}}, ns)
        if "{func_name}" not in ns or not isinstance(ns.get("{func_name}"), types.FunctionType):
            raise ValueError("Expected function '{func_name}' not found in snippet.")
        target = ns["{func_name}"]
        result = target({kwargs_pass})
        return result

    # Decorate after definition to register with FastMCP
    _decorator = mcp.tool(name="{tool_name}", description={json.dumps(description)})
    registered = _decorator(_wrapper)
    return registered
'''
        path = os.path.join(base_dir, f"{module_name}.py")
        with open(path, "w", encoding="utf-8") as f:
            f.write(file_text)
        return path
    return _impl()

def load_all_registered(mcp, base_dir: str) -> List[str]:
    """
    Import every module in ``base_dir`` and call its ``register(mcp)`` function.
    Returns a list of module names that were registered.
    """
    def _impl() -> List[str]:
        import os
        import importlib.util
        import sys
        loaded: List[str] = []
        if not os.path.isdir(base_dir):
            return loaded
        if base_dir not in sys.path:
            sys.path.insert(0, base_dir)
        for fn in sorted(os.listdir(base_dir)):
            if not fn.endswith(".py"):
                continue
            path = os.path.join(base_dir, fn)
            name = os.path.splitext(fn)[0]
            spec = importlib.util.spec_from_file_location(name, path)
            mod = importlib.util.module_from_spec(spec)
            assert spec and spec.loader
            spec.loader.exec_module(mod)  # type: ignore[assignment]
            if hasattr(mod, "register"):
                mod.register(mcp)
                loaded.append(name)
        return loaded
    return _impl()

def delete_tool_module(base_dir: str, module_name: str) -> bool:
    """
    Remove a generated tool module by name.

    Returns ``True`` if the file was removed, ``False`` if it did not exist.
    """
    def _impl() -> bool:
        import os
        path = os.path.join(base_dir, f"{module_name}.py")
        if os.path.exists(path):
            os.remove(path)
            return True
        return False
    return _impl()