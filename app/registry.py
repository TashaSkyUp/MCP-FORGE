"""
Helpers for writing and loading collected tool modules.

This module hides filesystem operations and module loading behind function
calls that defer imports to respect the style preference that imports live
inside functions.
"""

from __future__ import annotations
from typing import List, Tuple, Any, Dict

def _get_tool_name_from_source(path: str) -> str | None:
    """Read a module file and parse it to find the tool name."""
    import re
    with open(path, "r", encoding="utf-8") as f:
        content = f.read()
        # Find: _decorator = mcp.tool(name="...", description="...")
        match = re.search(r"mcp\.tool\s*\(\s*name=\"([^\"]+)\"", content)
        if match:
            return match.group(1)
    return None

def ensure_dirs(base_dir: str) -> str:
    """Ensure ``base_dir`` exists, creating it if necessary, and return it."""
    def _impl() -> str:
        import os
        os.makedirs(base_dir, exist_ok=True)
        return base_dir
    return _impl()

def safe_mod_name(name: str) -> str:
    """Sanitize an arbitrary string into a valid Python module name."""
    def _impl() -> str:
        import re
        s = re.sub(r"[^a-zA-Z0-9_]+", "_", name.strip())
        if not s:
            s = "tool"
        if s[0].isdigit():
            s = "_" + s
        return s.lower()
    return _impl()

def write_tool_module(
    base_dir: str,
    module_name: str,
    code_blob: str,
    func_name: str,
    tool_name: str,
    description: str,
    arg_spec: List[Tuple[str, str]],
    example_params: Dict[str, Any] | None = None,
) -> str:
    """
    Persist a generated module that wraps a function from ``code_blob`` as an MCP tool.
    """
    def _impl() -> str:
        import os
        import json
        ensure_dirs(base_dir)
        args_decl = ", ".join([f"{n}: {t}" for (n, t) in arg_spec]) or ""
        kwargs_pass = ", ".join([f"{n}={n}" for (n, _t) in arg_spec]) or ""
        file_text = f'''# AUTO-GENERATED BY MCPForge. Do not edit by hand.
from typing import Any

def register(mcp):
    """Register tool '{tool_name}' from collected code snippet."""
    def _wrapper({args_decl}) -> Any:
        # All imports inside function, per style preference.
        import types
        ns = {{}}
        src = {json.dumps(code_blob)}
        # Execute snippet in isolated namespace
        exec(src, {{}}, ns)
        if "{func_name}" not in ns or not isinstance(ns.get("{func_name}"), types.FunctionType):
            raise ValueError("Expected function '{func_name}' not found in snippet.")
        target = ns["{func_name}"]
        result = target({kwargs_pass})
        return str(result)

    # Decorate after definition to register with FastMCP
    _decorator = mcp.tool(name="{tool_name}", description={json.dumps(description)})
    registered = _decorator(_wrapper)
    return registered
'''
        path = os.path.join(base_dir, f"{module_name}.py")
        with open(path, "w", encoding="utf-8") as f:
            f.write(file_text)
        # Persist example parameters alongside the module for later testing
        meta_path = os.path.join(base_dir, f"{module_name}.json")
        with open(meta_path, "w", encoding="utf-8") as mf:
            import json
            json.dump({"tool_name": tool_name, "example_params": example_params or {}}, mf)
        return path
    return _impl()

def load_all_registered(mcp, base_dir: str) -> Dict[str, str]:
    """
    Import every module in ``base_dir`` and call its ``register(mcp)`` function.
    Returns a map from module names to registered tool names.
    """
    def _impl() -> Dict[str, str]:
        import os
        import importlib.util
        import sys
        loaded: Dict[str, str] = {}
        if not os.path.isdir(base_dir):
            return loaded
        if base_dir not in sys.path:
            sys.path.insert(0, base_dir)
        for fn in sorted(os.listdir(base_dir)):
            if not fn.endswith(".py"):
                continue
            path = os.path.join(base_dir, fn)
            name = os.path.splitext(fn)[0]
            tool_name = _get_tool_name_from_source(path)
            if not tool_name:
                continue
            spec = importlib.util.spec_from_file_location(name, path)
            mod = importlib.util.module_from_spec(spec)
            assert spec and spec.loader
            spec.loader.exec_module(mod)  # type: ignore[assignment]
            if hasattr(mod, "register"):
                mod.register(mcp)
                loaded[name] = tool_name
        return loaded
    return _impl()

def delete_tool_module(base_dir: str, module_name: str) -> bool:
    """
    Remove a generated tool module by name.

    Returns ``True`` if the file was removed, ``False`` if it did not exist.
    """
    def _impl() -> bool:
        import os
        path = os.path.join(base_dir, f"{module_name}.py")
        meta_path = os.path.join(base_dir, f"{module_name}.json")
        removed = False
        if os.path.exists(path):
            os.remove(path)
            removed = True
        if os.path.exists(meta_path):
            os.remove(meta_path)
            removed = True or removed
        return removed
    return _impl()


def load_example_params(base_dir: str) -> Dict[str, Dict[str, Any]]:
    """Load stored example parameters for each module in ``base_dir``."""
    def _impl() -> Dict[str, Dict[str, Any]]:
        import os
        import json
        data: Dict[str, Dict[str, Any]] = {}
        if not os.path.isdir(base_dir):
            return data
        for fn in os.listdir(base_dir):
            if fn.endswith('.json'):
                path = os.path.join(base_dir, fn)
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        meta = json.load(f)
                    module = os.path.splitext(fn)[0]
                    params = meta.get('example_params', {})
                    data[module] = params
                except (json.JSONDecodeError, IOError):
                    continue
        return data
    return _impl()
